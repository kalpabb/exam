RPC
============
Ascii
------------
X file
_______________
struct leter{
    char le;
};


program ASCIIPROGRAM{


    version ASCIIVERSION{

        int findvalue(leter)=1;

    }=1;

}=0x12345678;

client
_______________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ascii.h"


void
asciiprogram_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	leter  findvalue_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, ASCIIPROGRAM, ASCIIVERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	
	printf("Enter the leter:");
	scanf("%c",&findvalue_1_arg.le);


	result_1 = findvalue_1(&findvalue_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}else
	{
		printf("%d",*result_1);
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	asciiprogram_1 (host);
exit (0);
}

Server
______________________________

#include "ascii.h"

int *
findvalue_1_svc(leter *argp, struct svc_req *rqstp)
{
	static int  result;

	int num = argp->le;
	result=num;

	return &result;
}

Calculator
============
X file
___________
struct number{
	int a;
	int b;
};

program CAL{
	version CALVER{
		int sum(number)=1;
		int sub(number)=2;
		int mul(number)=3;
		int dev(number)=4;
	}=1;

}=0x12345678;

Client
______________
struct number{
	int a;
	int b;
};

program CAL{
	version CALVER{
		int sum(number)=1;
		int sub(number)=2;
		int mul(number)=3;
		int dev(number)=4;
	}=1;

}=0x12345678;

Server
__________________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cal.h"

int *
sum_1_svc(number *argp, struct svc_req *rqstp)
{
	static int  result;

	result = argp->a + argp->b;

	return &result;
}

int *
sub_1_svc(number *argp, struct svc_req *rqstp)
{
	static int  result;

	result = argp->a - argp->b;

	return &result;
}

int *
mul_1_svc(number *argp, struct svc_req *rqstp)
{
	static int  result;

	result = argp->a * argp->b;

	return &result;
}

int *
dev_1_svc(number *argp, struct svc_req *rqstp)
{
	static int  result;

	result = argp->a / argp->b;

	return &result;
}

Prime Number
=============
X file
_____________
struct number{
	int a;
};


program PRIMEPRO{
	
	version PRIMEVERSION{

		int cprime(number)=1;

	}=1;


}=0x12345678;

Client
___________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "prime.h"


void
primepro_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	number  cprime_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, PRIMEPRO, PRIMEVERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	printf("Enter the number");
	scanf("%d",&cprime_1_arg.a);

	result_1 = cprime_1(&cprime_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}else
	{
		if (*result_1==1)
		{
			printf("prime number\n");
		}else
		{
			printf("Not a primeNumber\n");
		}
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	primepro_1 (host);
exit (0);
}

Server
_______________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "prime.h"

int *
cprime_1_svc(number *argp, struct svc_req *rqstp)
{
	static int  result;

	int isprime=1;

	if(argp->a <=1)
	{
		isprime=0;
	}else
	{
		for(int i=2;i<=argp->a/2;i++)
		{
			if(argp->a % i==0)
			{
				isprime=0;
			}
		}

		if(isprime==1)
		{
			result = 1;
		}else
		{
			result = 0;
		}
	}

	return &result;
}

Factorial
=============
X file
______________
struct num{
	
	int a;
};


program FACT{
	
	version FACTVERSION{

		int factorial(num)=1;

	}=1;

}=0x12345678;

Client
______________

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fa.h"


int
fact_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	num  factorial_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FACT, FACTVERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	printf("Enter the number:");
	scanf("%d",&factorial_1_arg.a);

	result_1 = factorial_1(&factorial_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}else
	{
		printf("factorial value is :%d\n",*result_1);
	}




#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	fact_1 (host);
exit (0);
}

Server
______________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fa.h"

int *
factorial_1_svc(num *argp, struct svc_req *rqstp)
{
	static int  result;

	int fat =1;
	for(int i=1;i<=argp->a;i++)
	{
		fat = fat * i;
	}

	result = fat;

	return &result;
}

First Name, Last Name
===================
X file
____________________
program NAMEPRO{
	

	version FNAMEVERSION{


		string fname(void)=1;

	}=1;

	version LNAMEVERSION{

		string lname(void)=1;

	}=2;


}=0x12345678;

Client
__________________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "name.h"


void
namepro_1(char *host)
{
	CLIENT *clnt;
	char * *result_1;
	char *fname_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, NAMEPRO, FNAMEVERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = fname_1((void*)&fname_1_arg, clnt);
	if (result_1 == (char **) NULL) {
		clnt_perror (clnt, "call failed");
	}
	printf("First name:%s\n",*result_1);
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


void
namepro_2(char *host)
{
	CLIENT *clnt;
	char * *result_1;
	char *lname_2_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, NAMEPRO, LNAMEVERSION, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	result_1 = lname_2((void*)&lname_2_arg, clnt);
	if (result_1 == (char **) NULL) {
		clnt_perror (clnt, "call failed");
	}
	printf("last Name:%s\n",*result_1);
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	namepro_1 (host);
	namepro_2 (host);
exit (0);
}

Server
______________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "name.h"

char **
fname_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result="lahiru";

	return &result;
}

char **
lname_2_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	result="Buddhika jayasundara";

	return &result;
}


Find Vowel
=============
X file
_________________________
struct charactor{
	char test;
};

program FindVovels{
	
	version vovel_version{

		char vovelf(charactor)=1;

	}=1;

}=0x12341234;

Client
_________________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "findvovel.h"


void
findvovels_1(char *host)
{
	CLIENT *clnt;
	char  *result_1;
	charactor  vovelf_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FindVovels, vovel_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	printf("Enter the charactor :");
	char myvar;
	scanf("%c", &myvar);

	vovelf_1_arg.test = myvar;

	result_1 = vovelf_1(&vovelf_1_arg, clnt);
	if (result_1 == (char *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result_1=='y')
	{
		printf("This is a vovel charactor");
	}else{
		printf("This is not a vovel charactor");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	findvovels_1 (host);
exit (0);
}

server
________________________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "findvovel.h"

char *
vovelf_1_svc(charactor *argp, struct svc_req *rqstp)
{
	static char  result;

	char c= argp->test;

	if (c=='a' || c=='e' || c=='i' || c=='o' || c=='u')
	{
		result = 'y';
	}else{
		result = 'n';
	}

	/*
	 * insert server code here
	 */

	return &result;
}

Leap Year
=================
X file
________________
struct year{
	int y;
};

program Findyear{

	version Findyear_1{

			int Add(year)=1;

	} = 1;
	
} = 0x12345678;

Client
_______________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "lyear.h"


void
findyear_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	year  add_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, Findyear, Findyear_1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	printf("Enter the Year");
	scanf("%d", &add_1_arg.y);

	result_1 = add_1(&add_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}


	if (*result_1 ==1){
		printf(" is a leap Year");

	}else{
		printf("%d is not a leap Year",add_1_arg.y);
	}


#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	findyear_1 (host);
exit (0);
}

Server
_______________________________
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "lyear.h"

int *
add_1_svc(year *argp, struct svc_req *rqstp)
{
	static int  result;

	int y = argp->y;

	if ( y%4 ==0 && y%100 != 100 || y%400==0){

		result = 1;

	}else{

		result = 0;

	}

	/*
	 * insert server code here
	 */

	return &result;
}
=====
RMI
=====
calculator
--------
Int
_________
import java.rmi.*;

interface CalInt extends Remote{

	public int sum(int x,int y) throws RemoteException;
	public int sub(int x,int y) throws RemoteException;
	public int mul(int x,int y) throws RemoteException;
	public int div(int x,int y) throws RemoteException;

}

client
______
import java.rmi.Naming;
import java.util.*;

class CalClient{

	public static void main(String args[]){

		try{

			Scanner sc = new Scanner(System.in);

			CalInt h = (CalInt) Naming.lookup("name");

			System.out.println("Enter First number: ");
			int x = sc.nextInt();
			System.out.println("Enter second number: ");
			int y = sc.nextInt();

			System.out.println("Addition is: " +h.sum(x,y));
			System.out.println("substraction is: " +h.sub(x,y));
			System.out.println("Multiplication is: " +h.mul(x,y));
			System.out.println("Division is: " +h.div(x,y));


		} catch (Exception e){

			System.out.println("error" +e);
		}
	}
}

Imlimentation
______________
import java.rmi.*;
import java.rmi.server.*;

class CalImp extends UnicastRemoteObject implements CalInt{


 public CalImp() throws RemoteException{

 	super();
 }

 public int sum(int x, int y) throws RemoteException{

 	return x+y;
 }

 public int sub(int x, int y) throws RemoteException{

 	return x-y;
 }
 public int mul(int x, int y) throws RemoteException{

 	return x*y;
 }
 public int div(int x, int y) throws RemoteException{

 	return x/y;
 }
}

server
________
import java.rmi.Naming;

class CalServer{

	public static void main (String args[]){

		try{

			CalImp h = new CalImp();
			Naming.rebind("name",h);

			System.out.print("Server is ready");



		} catch (Exception e){

			System.out.print("eror" +e);
		}
	}
}

Sum Of Natural Number
---------------------
Int
_________
import java.rmi.*;

interface SumInt extends Remote{

	public int add(int start, int end) throws RemoteException;
}

Imp
________
import java.rmi.*;
import java.rmi.server.*;

class SumImp extends UnicastRemoteObject implements SumInt{


	public SumImp() throws RemoteException{

		super();
	}

	public int add(int start, int end) throws RemoteException{

		int sum =0;

		for(int i =start; i<=end;i++){

			sum= sum+i;
		}

		return sum;
	}
}

Client
________
import java.rmi.Naming;
import java.util.*;

class SumClient{

	public static void main(String args[]){


		try{

			Scanner sc = new Scanner (System.in);

			SumInt obj = (SumInt) Naming.lookup("name");

			System.out.println("Enter Start number: ");
			int start = sc.nextInt();

			System.out.println("Enter end number: ");
			int end = sc.nextInt();

			System.out.println("Sum is:  "+obj.add(start,end));
		




		}catch (Exception e){

			System.out.println("error" +e);
		}
	}
}

Server
__________
import java.rmi.Naming;

class SumServer{

	public static void main(String args[]){

		try{

			SumImp obj = new SumImp();

			Naming.rebind("name",obj);

			System.out.println("Server is ready");


		}catch (Exception e){

			System.out.println("error" +e);
		}
	}
}

Leap 
-------
server
__________
import java.rmi.*;
import java.rmi.Naming;

class leapserver{
	public static void main(String[]args){
		
		try{
			leapimp L = new leapimp(); 
			Naming.rebind("xyz",L);
			System.out.println("Server is running...");
			
		}
		catch(Exception e){
			System.out.println("Error : "+e);
		}
	}
}
client
___________
import java.rmi.*;
import java.rmi.Naming;
import java.util.Scanner;

class leapclient{
	public static void main(String[]args){
	
		try{
			leapint L = (leapint) Naming.lookup("xyz");
			Scanner sc = new Scanner(System.in);
			System.out.println("Ente the Year");
			
			int year = sc.nextInt();
			
			System.out.println(L.check(year));
			
			
		}
		catch(Exception e){
			System.out.println("Error : "+e);
		}
	}
}

Int
_______
import java.rmi.*;

interface leapint extends Remote{
	public String check(int x) throws RemoteException;
}

Imp
__________
import java.rmi.*;
import java.rmi.server.*;

class leapimp extends UnicastRemoteObject implements leapint{
	
	public leapimp() throws RemoteException{
		super();
	}
	
	public String check(int x) throws RemoteException{
		if(x%400 == 0 && x%100!=0 || x%4==0){
			return "This Year is a Leap Year";
		}
		else{
			return "This Year is not a Leap Year";
		}
		
	}
	
}

My
-------
Imp
_________
import java.rmi.*;
import java.rmi.server.*;
import java.rmi.registry.*;

public class Myimp extends UnicastRemoteObject implements Myint{

    public Myimp() throws RemoteException {
        super();
    }

    public int sum(int a, int b) throws RemoteException{

        return a+b;
    }
    
}

Int
_________
import java.rmi.*;

interface Myint extends Remote{

        public int sum(int a, int b)throws RemoteException;
    
}

client
___________
import java.rmi.Naming;

public class Myclient {

    public static void main(String[] args) {

        try {

            Myint myint = (Myint) Naming.lookup("test");

            System.out.println(myint.sum(10,10));

            
        } catch (Exception e) {
            System.out.println(e);
        }
        
    }
    
}


server
__________
import java.rmi.Naming;

public class Myserver {

    public static void main(String[] args) {

        try {

            Myimp myimp = new Myimp();
            
            Naming.rebind("test", myimp);
            System.out.println("Server is running");
            
        } catch (Exception e) {
            System.out.println(e);
        }
        
    }
    
}

Range Calculation
------------------
client
______________
import java.rmi.Naming;
import java.util.Scanner;

public class nclient{

	public static void main(String[] args) {

		try{

			Scanner sc = new Scanner(System.in);

			nint myobj = (nint)Naming.lookup("test");
			int a;
			int b;

			System.out.println("Enter staring point : ");
			a = sc.nextInt();

			System.out.println("Enter End point : ");
			b = sc.nextInt();

			System.out.println("Sum of this range = "+myobj.sumofrange(a,b));


			

		}catch(Exception e){

		}
	}
}

IMp
__________
import java.rmi.*;
import java.rmi.server.*;



public class nimp extends UnicastRemoteObject implements nint{

	public nimp() throws RemoteException{
		super();
	}


	public int sumofrange(int lb, int ub) throws RemoteException{

		int sum=0;

		for (int i=lb; i<=ub; i++) {
			sum +=i;
		}

		return sum;
	}


}


Int
_________
import java.rmi.*;


interface nint extends Remote{

	public int sumofrange(int lb, int ub) throws RemoteException;
}

server
___________
import java.rmi.Naming;


public class nserver{

	public static void main(String[] args) {
		
		try{

			nimp myobj = new nimp();

			Naming.rebind("test", myobj);

			System.out.println("server is running");


		}catch(Exception e){

		}
	}
}
===================
MPI
===================
Area.c
-------
#include<mpi.h>
#include<stdio.h>

int main(){

MPI_Init(NULL,NULL);

int length,width,area;

int rank;
MPI_Comm_rank(MPI_COMM_WORLD,&rank);

int size;
MPI_Comm_size(MPI_COMM_WORLD,&size);

if(rank == 0){
	printf("Enter the Width");
	scanf("%d",&width);
	printf("Enter the length");
	scanf("%d",&length);
	
	MPI_Send(&width,1,MPI_INT,1,0,MPI_COMM_WORLD);
	MPI_Send(&length,1,MPI_INT,1,0,MPI_COMM_WORLD);
	
}
else if(rank == 1){
	MPI_Recv(&width,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
	MPI_Recv(&length,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
	
	area = width*length;
	
	MPI_Send(&area,1,MPI_INT,2,1,MPI_COMM_WORLD);
	
}
else if(rank == 2){
	MPI_Recv(&area,1,MPI_INT,1,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
	
	printf("Area = %d",area);

}


MPI_Finalize();

}

Number
-----------
#include<mpi.h>
#include<stdio.h>
#include<stdlib.h>

int main(int argc,char** argv[])
{
	MPI_Init(NULL,NULL);

	int world_rank;
	MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);
	int world_size;
	MPI_Comm_size(MPI_COMM_WORLD,&world_size);


int num1;
	if(world_rank==0)
	{
		num1=50;

		MPI_Send(&num1, 1, MPI_INT, 1, 0, MPI_COMM_WORLD );

	}else if(world_rank==1)
	{

		MPI_Recv(&num1, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

		printf("The value of the number is:%d\n",num1);

	}

MPI_Finalize();
return 0;
}

Prime
__________
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


	void prime(int a)
	{
		bool isprime=true;
		if(a==1)
		{
			isprime=false;
		}else
		{

			for(int i=2;i<=a/2;i++)
			{
				if(a%i==0)
				{
					isprime=false;
					break;
				}
			}
		}
		if (isprime)
			{
				printf("Prime number\n");
			}else
			{
				printf("Not Prime number\n");
			}

	}


int main(int argc, char** argv[])
{

	MPI_Init(NULL,NULL);

	int world_rank;
	MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);
	int world_size;
	MPI_Comm_size(MPI_COMM_WORLD,&world_size);

	

int num;
	if (world_rank==0)
	{
		

		printf("Enter the number:\n");
		scanf("%d",&num);

		MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);

	}
	if (world_rank==1)
	{
		MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);

		prime(num);

	}





	MPI_Finalize();
	return 0;
}



Factorial
___________
#include<mpi.h>
#include<stdlib.h>
#include<stdio.h>


 

int main(int argc,char ** argv[])
{
     int factorials(int num)
    {
        int fact=1;
        
        for(int i=1;i<=num;i++)
        {
           fact = fact * i;
        }

        return fact;
    }
    
    MPI_Init(NULL,NULL);

    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD,&world_size);

int num;
int value;

    if(world_rank==0)
    {
        printf("Enter the number:\n");
        scanf("%d",&num);


        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);

    }else if(world_rank==1)
    {
        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE); 

        value=factorials(num);
        
        MPI_Send(&value,1,MPI_INT,2,1,MPI_COMM_WORLD);

    }else if(world_rank==2)
    {
        MPI_Recv(&value,1,MPI_INT,1,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE); 

        printf("Factorial value is:%d\n",value);
    }

    MPI_Finalize();
    return 0;

}

Area max
_____________
#include<mpi.h>
#include<stdio.h>
#include<stdlib.h>

int main(int argc, char** argv[])
{
    MPI_Init(NULL,NULL);

    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);

    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD,&world_size);

    
    int Tri_h,Tri_a,Tri_b,Tri_base,Tri_area,Tri_peri;
    int Cyl_h,Cyl_r,Cyl_area,Cyl_peri;
    int Cir_r,Cir_area,Cir_peri;
    const float pie = 3.14;

 

    if (world_rank == 0){
        printf("Enter the height of triangle : ");
        scanf("%d",&Tri_h);
        printf("Enter the length of base of triangle : ");
        scanf("%d",&Tri_base);

        printf("Enter the length of next side: ");
        scanf("%d",&Tri_a);

        printf("Enter the length of next side : ");
        scanf("%d",&Tri_b);

        printf("Enter the height of cylinder : ");
        scanf("%d",&Cyl_h);

        printf("Enter the radius of cylinder : ");
        scanf("%d",&Cyl_r);

        printf("Enter the radius of circle : ");
        scanf("%d",&Cir_r);


        MPI_Send(&Tri_h, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        MPI_Send(&Tri_a, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        MPI_Send(&Tri_b, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        MPI_Send(&Tri_base, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);

        MPI_Send(&Cyl_h, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        MPI_Send(&Cyl_r, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);

        MPI_Send(&Cir_r, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);

    }
    else if(world_rank == 1){
        
        MPI_Recv(&Tri_h, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_a, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_b, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_base, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        
        MPI_Recv(&Cyl_h, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Cyl_r, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Cir_r, 1, MPI_INT, 0, 0, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        Tri_area=Tri_h*Tri_base*0.5;
        Tri_peri=Tri_a+Tri_b+Tri_base;
        

        MPI_Send(&Cyl_h, 1, MPI_INT, 2, 1, MPI_COMM_WORLD);
        MPI_Send(&Cyl_r, 1, MPI_INT, 2, 1, MPI_COMM_WORLD);

        MPI_Send(&Cir_r, 1, MPI_INT, 2, 1, MPI_COMM_WORLD);

        MPI_Send(&Tri_area, 1, MPI_INT, 2, 1, MPI_COMM_WORLD);
        MPI_Send(&Tri_peri , 1, MPI_INT, 2, 1, MPI_COMM_WORLD);

    }
    else if(world_rank == 2){

        MPI_Recv(&Cyl_h, 1, MPI_INT, 1, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Cyl_r, 1, MPI_INT, 1, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Cir_r, 1, MPI_INT, 1, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Tri_area, 1, MPI_INT, 1, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_peri, 1, MPI_INT, 1, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        Cyl_area=(2*pie*Cyl_r*Cyl_r)+(2*pie*Cyl_r*Cyl_r);
        Cyl_peri=(2*pie*Cyl_r)+(2*pie*Cyl_r*Cyl_h);

        MPI_Send(&Cir_r, 1, MPI_INT, 3, 2, MPI_COMM_WORLD);

        MPI_Send(&Tri_area, 1, MPI_INT, 3, 2, MPI_COMM_WORLD);
        MPI_Send(&Tri_peri, 1, MPI_INT, 3, 2, MPI_COMM_WORLD);

        MPI_Send(&Cyl_area, 1, MPI_INT, 3, 2, MPI_COMM_WORLD);
        MPI_Send(&Cyl_peri, 1, MPI_INT, 3, 2, MPI_COMM_WORLD);

    }

    else if(world_rank == 3){

        MPI_Recv(&Cir_r, 1, MPI_INT, 2, 2, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Tri_area, 1, MPI_INT, 2, 2, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_peri, 1, MPI_INT, 2, 2, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Cyl_area, 1, MPI_INT, 2, 2, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Cyl_peri, 1, MPI_INT, 2, 2, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        Cir_area=pie*Cir_r*Cir_r;
        Cir_peri=2*pie*Cir_r*Cir_r;

        MPI_Send(&Tri_area, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);
        MPI_Send(&Tri_peri, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);

        MPI_Send(&Cyl_area, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);
        MPI_Send(&Cyl_peri, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);

        MPI_Send(&Cir_area, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);
        MPI_Send(&Cir_peri, 1, MPI_INT, 4, 3, MPI_COMM_WORLD);


    }

    else if(world_rank == 4){

        MPI_Recv(&Tri_area, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Tri_peri, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Cyl_area, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Cyl_peri, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        MPI_Recv(&Cir_area, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);
        MPI_Recv(&Cir_peri, 1, MPI_INT, 3, 3, MPI_COMM_WORLD,MPI_STATUS_IGNORE);

        printf("Area of the Triangle = %d\nPerimeter of the Triangle  = %d\n\n",Tri_area,Tri_peri);
        printf("Area of the Cylinder = %d\nPerimeter of the Cylinder = %d\n\n",Cyl_area,Cyl_peri);
        printf("Area of the Circle = %d\nPerimeter of the Circle = %d\n\n",Cir_area,Cir_peri);
        

    }


    MPI_Finalize();

    return 0;
}
++++++
fotren++++++++++++
program add
use mpi
implicit none

integer::rank,size,ierr
integer::a,b,total

call MPI_init(ierr)

call MPI_Comm_rank(MPI_Comm_World,rank,ierr)
call MPI_Comm_size(MPI_Comm_World,size,ierr)

if(rank==0)then
	
	print*,"Enter First number:"
	read*,a

	print*,"Enter Second number:"
	read*,b

	call MPI_Send(a,1,MPI_Integer,1,0,MPI_Comm_World,ierr)
	call MPI_Send(b,1,MPI_Integer,1,0,MPI_Comm_World,ierr)


else if(rank==1)then
	
	call MPI_Recv(a,1,MPI_Integer,0,0,MPI_Comm_World,MPI_STATUS_IGNORE,ierr)
	call MPI_Recv(b,1,MPI_Integer,0,0,MPI_Comm_World,MPI_STATUS_IGNORE,ierr)

    total= a+b

    call MPI_Send(total,1,MPI_Integer,2,1,MPI_Comm_World,ierr)

else if(rank==2)then
	
	call MPI_Recv(total,1,MPI_Integer,1,1,MPI_Comm_World,MPI_STATUS_IGNORE,ierr)
	print*,total

end if
call MPI_Finalize(ierr)
end program add
_________
MPI PINGPONG
_______
#include <mpi.h>
#include <stdio.h>

#define PING_PONG_LIMIT 10

int main(int argc, char** argv) {
    // Initialize the MPI environment
    MPI_Init(&argc, &argv);

    // Get the rank of the process
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    // Get the number of processes
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    // Ensure we are working with exactly 2 processes
    if (world_size != 2) {
        fprintf(stderr, "World size must be 2 for this program\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    int ping_pong_count = 0;
    int partner_rank = (world_rank + 1) % 2;

    while (ping_pong_count < PING_PONG_LIMIT) {
        if (world_rank == ping_pong_count % 2) {
            // Increment the ping pong count and send it to the partner
            ping_pong_count++;
            MPI_Send(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);
            printf("Process %d sent ping_pong_count %d to process %d\n", world_rank, ping_pong_count, partner_rank);
        } else {
            // Receive the ping pong count from the partner
            MPI_Recv(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Process %d received ping_pong_count %d from process %d\n", world_rank, ping_pong_count, partner_rank);
        }
    }

    // Finalize the MPI environment
    MPI_Finalize();

    return 0;
}
_________
no of procees
______
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

#define DEFAULT_PING_PONG_LIMIT 10

int main(int argc, char** argv) {
    // Initialize the MPI environment
    MPI_Init(&argc, &argv);

    // Get the rank of the process
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    // Get the number of processes
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    // Set the ping-pong limit (modifiable via command-line arguments)
    int ping_pong_limit = DEFAULT_PING_PONG_LIMIT;
    if (argc > 1) {
        ping_pong_limit = atoi(argv[1]);
    }

    // Validate the number of processes
    if (world_size < 2) {
        fprintf(stderr, "World size must be at least 2 for this program\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    int ping_pong_count = 0;
    int partner_rank = (world_rank + 1) % world_size;

    while (ping_pong_count < ping_pong_limit) {
        if (ping_pong_count % world_size == world_rank) {
            // Increment the ping pong count and send it to the next process
            ping_pong_count++;
            MPI_Send(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);
            printf("Process %d sent ping_pong_count %d to process %d\n", world_rank, ping_pong_count, partner_rank);
        } else {
            // Receive the ping pong count from the previous process
            int source_rank = (world_rank - 1 + world_size) % world_size;
            MPI_Recv(&ping_pong_count, 1, MPI_INT, source_rank, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Process %d received ping_pong_count %d from process %d\n", world_rank, ping_pong_count, source_rank);
        }
    }

    // Finalize the MPI environment
    MPI_Finalize();

    return 0;
}
---
adition fortren
---
program Addition
    implicit none
    integer :: a, b, sum

    print *, "Enter two integers:"
    read *, a, b

    sum = a + b
    print *, "The sum is:", sum
end program Addition
-----
factorial num
----
program Factorial
    implicit none
    integer :: n, i, fact

    print *, "Enter a positive integer:"
    read *, n

    fact = 1
    do i = 1, n
        fact = fact * i
    end do

    print *, "The factorial of", n, "is", fact
end program Factorial
----
check EVEN or ODD
----
program EvenOdd
    implicit none
    integer :: num

    print *, "Enter an integer:"
    read *, num

    if (mod(num, 2) == 0) then
        print *, num, "is even."
    else
        print *, num, "is odd."
    end if
end program EvenOdd
----
sum of array
----
program ArraySum
    implicit none
    integer, dimension(5) :: arr
    integer :: i, sum

    print *, "Enter 5 integers:"
    read *, arr

    sum = 0
    do i = 1, 5
        sum = sum + arr(i)
    end do

    print *, "The sum of the array elements is:", sum
end program ArraySum
---
find the largest no
---
program ArraySum
    implicit none
    integer, dimension(5) :: arr
    integer :: i, sum

    print *, "Enter 5 integers:"
    read *, arr

    sum = 0
    do i = 1, 5
        sum = sum + arr(i)
    end do

    print *, "The sum of the array elements is:", sum
end program ArraySum
----
Area of a Circle
---
program CircleArea
    implicit none
    real :: radius, area
    real, parameter :: pi = 3.14159

    print *, "Enter the radius of the circle:"
    read *, radius

    area = pi * radius**2
    print *, "The area of the circle is:", area
end program CircleArea
----
code ping pong
-----
program MPI_PingPong
    use mpi
    implicit none

    integer :: rank, size, ierr
    integer :: ping_pong_count, partner
    integer, parameter :: ping_pong_limit = 10

    ! Initialize MPI
    call MPI_Init(ierr)

    ! Get rank and size
    call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
    call MPI_Comm_size(MPI_COMM_WORLD, size, ierr)

    ! Ensure only 2 processes
    if (size /= 2) then
        if (rank == 0) print *, "This program requires exactly 2 processes!"
        call MPI_Abort(MPI_COMM_WORLD, 1, ierr)
    end if

    ! Ping-pong logic
    ping_pong_count = 0
    partner = mod(rank + 1, 2)

    do while (ping_pong_count < ping_pong_limit)
        if (mod(ping_pong_count, 2) == rank) then
            ! Send the count
            ping_pong_count = ping_pong_count + 1
            call MPI_Send(ping_pong_count, 1, MPI_INTEGER, partner, 0, MPI_COMM_WORLD, ierr)
            print *, "Process ", rank, " sent ", ping_pong_count, " to process ", partner
        else
            ! Receive the count
            call MPI_Recv(ping_pong_count, 1, MPI_INTEGER, partner, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)
            print *, "Process ", rank, " received ", ping_pong_count, " from process ", partner
        end if
    end do

    ! Finalize MPI
    call MPI_Finalize(ierr)
end program MPI_PingPong












++++++
Run 
++++++

----
RPC
----
rpcgen -aC text.x
make -f Makefile.text
./text_server
./text_clientc localhost
-----
RMI
-----
javac textInt.java
javac textImp.java
rmic calserver
rmiregistry &
javac textserver.java
java calserver
>> new terminal
javac textclient.java
java textclient

----
MPI
----
touch one.c
mpicc ./text.c -o text
mpirun -np 3 .lone
____
MPI FOTREN run
__
mpi90f -O add add.f90
npirun -np 3 ./add
___
MPI PING PONG
___
mpicc -o ping_pong ping_pong.c
mpirun -np 4 ./ping_pong         //  For 4 processes
mpirun -np 4 ./ping_pong 20        // Set the ping-pong limit to 20








